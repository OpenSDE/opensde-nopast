#!/bin/sh
# --- SDE-COPYRIGHT-NOTE-BEGIN ---
# This copyright note is auto-generated by ./scripts/Create-CopyPatch.
#
# Filename: bin/sde-config-ini
# Copyright (C) 2006 - 2008 The OpenSDE Project
#
# More information can be found in the files COPYING and README.
#
# This program is free software; you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation; version 2 of the License. A copy of the
# GNU General Public License can be found in the file COPYING.
# --- SDE-COPYRIGHT-NOTE-END ---

[ -n "$SDEROOT" ] ||
	export SDEROOT=$( cd "${0%/*}/.."; pwd -P )

. $SDEROOT/lib/libsde.in

ini_usage() {
	local progname=${0##*/}
cat <<EOT
Usage:	$progname --file <file> --sections
	$progname --file <file> --keys <section>
	$progname --file <file> [--delete] section[.key] ...
	$progname --file <file> section[[.key]=value] ...

Valid aliases:
	--file (-F)
	--sections (-S)
	--keys (-K)
EOT
}

# splits an .ini file in three parts:
# * before the section ($tmpname.0)
# * the section ($tmpname.1)
# * after the section ($tmpname.2)
#
# USAGE: ini_split "file" "section" "tmpname"
#
ini_split() {
	local file="$1" section="$2" tmpname="$3"

	rm -rf $tmpname.{0,1,2}

	if [ ! -e "$file" ]; then
		# create the file if it's not there
		touch "$file" || echo_abort 1 "$file: can't write."
	fi

	[ -f "$file" -a -w "$file" ] || echo_abort 1 "$file: can't write."

	gawk "BEGIN { level=0; }
	/^\[/ {
		if ( level == 0 && \$0 ~ /^\[$section\][ \t]*\$/ )
			level=1;
		else if ( level == 1 )
			level=2;
	}
	{ print > \"$tmpname.\" level }
	" "$file"

	# clean empty lines on the section to alter
	[ ! -s "$tmpname.1" ] || sed -i -e "/^[ \t]*$/d;" "$tmpname.1"

}

# merge a previously split .ini file
# USAGE: ini_merge "file" "section" "tmpname"
#
ini_merge() {
	local file="$1" tmpname="$2"
	local x=

	# new empty line at the end of the section, if there is a next
	if [ -s "$tmpname.1" -a -s "$tmpname.2" ]; then
		echo >> "$tmpname.1"
	fi

	for x in 0 1 2; do
		if [ -s $tmpname.$x ]; then
			cat $tmpname.$x
		fi
	done > "$file"

	rm -rf $tmpname.{0,1,2}
}

# dumps the raw content of a section
# USAGE: ini_section_raw "file" "section"
#
ini_section_raw() {
	gawk "BEGIN { show=0; }
	/^\[/ {
		if ( \$0 ~ /^\[$2\][ \t]*\$/ )
			show=1;
		else
			show=0;
		}
	/^[^\[]/ { if ( show ) print; }" "$1"
}

shortopts='F:SK:'
longopts='file:,sections,keys:,delete'
options=$( getopt -o "$shortopts" -l "$longopts" -- "$@" )
if [ $? -ne 0 ]; then
	ini_usage
	exit -1
fi

# load new arguments list
eval set -- "$options"

if [ $# -lt 2 ]; then
	ini_usage
	exit -1
fi

file=
delete=
while [ $# -gt 0 ]; do
	case "$1" in
		-F|--file)	shift; file="$1" ;;
		--delete)	delete=yes ;;

		--)		shift; break ;;

		-S|--sections)
			[ -r "$file" ] || echo_abort 1 "${file:-none}: can't read."

			exec sed -n -e 's,^\[\(.*\)\][ \t]*$,\1,p' "$file"
			;;
		-K|--keys)
			[ -r "$file" ] || echo_abort 1 "${file:-none}: can't read."

			ini_section_raw "$file" "$2" |
				sed -n -e 's,^[ \t]*\([^;= ]*\)[ \t]*=.*,\1,p'
			exit $?
			;;
	esac
	shift
done

if [ -z "$file" ]; then
	echo_abort 1 "no ini file specified."
fi

oldsection=
tmpfile="$file.$$"
section= key= value= action=

for item; do
	# parse 'item'
	section="${item%%.*}"
	value="${item#*=}"
	key="${item#*.}"; key="${key%%=*}"

	[ "$section" != "$key" ] || key=

	# choose an action
	if [ "$value" = "$item" ]; then
		if [ -n "$delete" ]; then
			action='delete'
		else
			action='get'
		fi
	else
		action='set'
	fi

	case "$action" in
		get)	[ -r "$file" ] || echo_abort 1 "${file:-none}: can't read."

			if [ -n "$key" ]; then
				# just on key
				ini_section_raw "$file" "$section" | sed -n \
					-e "s,^[ \t]*$key[ \t]*=\(.*\),\1,p"
			else
				# the entire section, as variables
				ini_section_raw "$file" "$section" | sed \
					-e '/^[ \t]*;/d;' -e '/^[ \t]*$/d;' -e 's,",\\",g' -e 's,=\(..*\)$,="\1",'
			fi ;;
		set)
			if [ -n "$oldsection" -a "$oldsection" != "$section" ]; then
				# close previous split
				ini_merge "$file" "$tmpfile"
				oldsection=
			fi

			if [ -z "$oldsection" ]; then
				# split before mangling
				ini_split "$file" "$section" "$tmpfile"
				oldsection="$section"
			fi

			if [ ! -s "$tmpfile.1" ]; then
				# new section
				if [ -s "$tmpfile.0" ]; then
					# empty line at the end of the last section
					echo >> "$tmpfile.0"
				fi
				echo -e "[$section]" >> "$tmpfile.1"
			fi

			if grep -q "^[ \t]*$key[ \t]*=" $tmpfile.1; then
				sed -i -e "s|^[ \t]*$key[ \t]*=.*|$key=$value|" "$tmpfile.1"
			else
				echo "$key=$value" >> "$tmpfile.1"
			fi
			;;
		delete)
			if [ -n "$oldsection" -a "$oldsection" != "$section" ]; then
				# close previous split
				ini_merge "$file" "$tmpfile"
				oldsection=
			fi

			if [ -z "$oldsection" ]; then
				# split before mangling
				ini_split "$file" "$section" "$tmpfile"
				oldsection="$section"
			fi

			if [ -n "$key" ]; then
				# just on key
				grep -v "^[ \t]*$key[ \t]*=" "$tmpfile.1" > "$tmpfile.1+"
				mv -f "$tmpfile.1+" "$tmpfile.1"
			else
				# the entire section
				echo "[$section]" > "$tmpfile.1"
			fi
			;;
	esac
done

if [ -n "$oldsection" ]; then
	ini_merge "$file" "$tmpfile"
fi
